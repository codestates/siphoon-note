# 하나의 동작을 단위로, 변경될 여지가 없는 코어 비지니스 로직을 하나로 테스트

## 유닛 테스트를 먼저 작성하는 목적은 "코드가 최소 단위로 책임을 나눠갖고 있는지" 파악하기 위함.
## 단일 책임 원칙을 지킨다면 추후 클린 아키텍처의 원칙을 따르는 구조로 리팩토링이 수월해질 것이라 기대하기 때문.

_* 유저아이디란 가입 시 입력한 이메일_

### essay
1. 글 조회
  로그인한 사용자는 본인 페이지에서 작성한 글 목록을 볼 수 있다
  
  given: 조회하려는 유저 아이디, 비밀번호 -> (이거 mock으로 넣어야 하는지, 하드코딩으로 값을 주는게 좋을지, 실제 데이터 가져오면 의존성이 높아지는 건가?)
  when: 주어진 계정 정보가 맞다면, 정보가 일치하지 않는다면
  then: 해당 유저가 작성한 글 카드 30개의 데이터를 받아온다

2. 글 쓰기
  (타이머 동작 시작, 태그 갯수 제한 -> 프론트)
  given: 유저가 글을 작성, 태그(최대 3개)를 입력한다면 (공개 여부 default: false)
  when: 글쓰기 저장 요청이 들어온다 (Q. request를 받아서 처리하는 컨트롤러는 유닛테스트에서 확인해야 할까? 이건 통합테스트 아닐지)
  then: 글 내용, isPublic, tagList는 받아온 입력값을, 유저 아이디, 작성 시간(yy-mm-dd hh:mm:ss), 수정 시간은 서비스에서 자동 생성 후, 기존의 글 목록에 새 글을 추가한다

3. 글 수정: 내용, 태그, isPublic, 수정날짜 등의 속성을 변경 / 글 카드에 호버했을 때 나타나는 휴지통 아이콘을 클릭하면 isDeleted:true로 변경
  given: 속성을 수정하고자 하는 글이 있음
  when: 해당 글에서 내용, 태그, isPublic, isDeleted 속성을 변경한다면,
  then: 수정하려는 글 카드의 내용이 수정되어 글 목록에 반영되어야 한다

4. 글 삭제
  given: 사용자 id, 글 고유 id가 주어지고
    (유저가 휴지통 목록 조회를 위해 Trash 토글 버튼을 누르면 'yymmdd 작성 내용 15글자' 리스트가 보이고 -> 이건 e2e 테스트) 
  when: (유저가 휴지통 목록에서 삭제할 글을 선택하면 '영구 삭제' 알림을 모달로 띄우고) 여기에서 '삭제 확인'을 누르면
  then: 해당 글을 db에서 삭제하도록 처리한다

---
5, 6 -> 이건 서버에 요청없이 처리되는 편이 종을 듯 (e.g. 장바구니에서 모든 상품목록의 선택해제를 했는데, 화면전환이 되어야 선택해제가 된다면 사용성이 떨어짐..)

5. 휴지통 목록 조회: isDeleted는 글의 속성이므로 essay가 관리한다 
6. 나의 태그 목록 조회..... 이걸 essay가 관리할지, user가 관리할지??
태그는 사용자 정보에 종속된건가, 글 정보에 종속된건가 -> 태그는 특정 글에 포함된 것이므로 essay에 포함
---

Q.user랑 auth가 어떻게 역할 분담이 되는거지?
auth는 인증이 필요한 케이스...
로그인 상태인 걸 서비스가 알고 있다면, 계정 crud에서 인증을 반복할 필요는 없겠지??

### user
1. 나의 습관 기록 조회
  given: 유저 아이디 필요, 조회할 기간은 가입일 이후 ~ 조회 일자부터
  when: 로그인 후 글 목록 옆의 넘어가기 버튼 클릭 시 
  then: 현재일자까지 작성한 모든 글의 개수, 연속 작성일, 가입일 이후 최대 작성일 3가지 기록을 출력함

2. 캘린더 조회 (Q. 한번에 해당월 데이터만 보낼지, 이전 이력 전부를 보낼지, *일부를 보낼지)
  given: 유저 아이디, 조회일
  when: 글 목록 화면 전환 버튼 클릭 시(습관 조회 요청이 오면),
  then: 해당월 -6개월의 습관 OX 리스트

2. 나의 정보 조회
  given: 유저 아이디
  when: 유저가 본인의 회원 정보 조회를 요청하면
  then: 프로필 이미지, 가입한 이메일, *서비스 닉네임, *블럭 처리된 패스워드, 가입일자, 마지막 정보 수정일자를 출력함

3. 나의 정보 수정
  given: 유저 아이디로 '회원 정보 조회' 상태에서
  when: (서비스 닉네임, 블럭처리된 패스워드는 입력이 가능한 상태) 닉네임, 패스워드 변경 입력 후 '저장'하기 요청이 들어오면
  then: 해당 유저의 정보를 변경 처리(Q.변경된 내용을 그대로 반영한 페이지를 보여줄지, 목록 조회화면으로 돌아갈지) 

### auth -> jwt가 필요한 유즈케이스
1. 이메일로 회원가입 (Q. 토큰 발급에 들어갈 유저 고유 정보로 uuid를 생성하는게 좋을지)
  given: (필수)이메일, 패스워드, (선택) 닉네임(default: ??), 성별, 지역 등의 정보 입력
  when: 회원 가입 요청 시, 중복 이메일이 아니라면
  then: 패스워드는 encrypt하고 이메일 + 가입일자(yymmdd hh:mm:ss) || uuid 로 refresh 토큰 발급해서 db에 다른 정보와 함께 신규 회원으로 입력

2. 로그인
  given: 이메일, 패스워드로 로그인 요청을 받고
  when: 해당 이메일이 db에 존재한다면 인풋 패스워드 === 복호화된 db의 패스워드가 일치한다면
  then: 해당 유저를 로그인 허가함

3. 로그아웃
  given: 특정 유저로부터 로그아웃 요청을 받으면
  when: 액세스 토큰 유효성 확인 후(Q. 로그아웃 권한이 있는지 확인하기 위함인지)
  then: 유효성이 확인되면 유저의 액세스 토큰 삭제

4. 계정삭제
  given: 특정 유저의 회원 탈퇴 요청이 들어오면
  when: 액세스 토큰 유효성 확인 후
  then: db의 리프레시 토큰과 대조 후 일치하면, 테이블에서 유저 정보 삭제